import sys
import math
import numpy as np
import pandas as pd

class FastAreader:
    def __init__(self, fname=''):
        '''contructor: saves attribute fname '''

        self.fname = fname
        self.fileH = None

    def doOpen(self):
        if self.fname == '':
            return sys.stdin
        else:
            return open(self.fname)

    def readFasta(self):

        header = ''
        sequence = ''

        with self.doOpen() as self.fileH:

            header = ''
            sequence = ''

            # skip to first fasta header
            line = self.fileH.readline()
            while not line.startswith('>'):
                line = self.fileH.readline()
            header = line[1:].rstrip()

            for line in self.fileH:
                if line.startswith('>'):
                    yield header, sequence
                    header = line[1:].rstrip()
                    sequence = ''
                else:
                    sequence += ''.join(line.rstrip().split()).upper()

        yield header, sequence

class CommandLine():
    '''
    Handle the command line, usage and help requests.

    CommandLine uses argparse, now standard in 2.7 and beyond. 
    it implements a standard command line argument parser with various argument options,
    a standard usage and help, and an error termination mechanism do-usage_and_die.

    attributes:
    all arguments received from the commandline using .add_argument will be
    avalable within the .args attribute of object instantiated from CommandLine.
    For example, if myCommandLine is an object of the class, and requiredbool was
    set as an option using add_argument, then myCommandLine.args.requiredbool will
    name that option.

    '''

    def __init__(self, inOpts=None):
        '''
        CommandLine constructor.
        Implements a parser to interpret the command line argv string using argparse.
        '''

        import argparse
        self.parser = argparse.ArgumentParser(
            description='Program prolog - a brief description of what this thing does',
            epilog='Program epilog - some other stuff you feel compelled to say',
            add_help=True,  # default is True
            prefix_chars='-',
            usage='%(prog)s [options] -option1[default] <input >output'
        )

        self.parser.add_argument('-l', '--minMotif', nargs='?', default=1, action='store',
                                 help='min kMer size ')
        self.parser.add_argument('-m', '--maxMotif', nargs='?', default=8, action='store',
                                 help='max kMer size ')
        self.parser.add_argument('-c', '--cutoff', nargs='?', type=float, default=.01, action='store',
                                 help='Zscore cutoff')


        self.parser.add_argument('-v', '--version', action='version', version='%(prog)s 0.1')
        if inOpts is None:
            self.args = self.parser.parse_args()
        else:
            self.args = self.parser.parse_args(inOpts)


#-----------------------------------------------------------------------------------------------------------------

class Motif():
    
    def __init__(self, DNA, k, t, pseudo=1, iterations=1000):
        # initialize variables
        self.bases = ['A', 'C', 'G', 'T']
        self.DNA = DNA
        self.k = k
        self.t = t
        self.pseudo = pseudo
        self.iterations = 1000
        
        # initialize null model using concantenated DNA sequences
        self.string =''.join(self.DNA)
        self.null = {base: (self.pseudo + self.string.count(base))/(len(self.string)+(self.pseudo*4)) for base in self.bases}
    
    def rand_motifs(self):
        # use RNG to create a bunch of random motifs
        motifs = []
        for seq in self.DNA:
            start_i = np.random.randint(0, len(seq)-self.k+1)
            end_i = start_i + self.k
            
            motifs.append(seq[start_i:end_i])  
        return motifs


    def Score(self, profile):
        # Find relative entropy score using profile table
        score = 0
        for x in range(self.k):
            for base in self.bases: 
                prob_x = profile.loc[base, x]
                score += prob_x * np.log2( prob_x/self.null[base] )
        return score
 
    
    def Count(self, motifs):
        # construct count table that's already filled with pseudo-count
        count_table = pd.DataFrame(    np.full((4,self.k), self.pseudo)   , index=self.bases    )
        
        # iterate over every motif and return a table with counts of bases
        for motif in motifs:
            for index, base in enumerate(motif): #bases and index correspond to rows and columns
                count_table.loc[base, index] += 1
        
        return count_table
    def Profile(self, motifs):
        # use count table to calculate profile probabilities using base count and sum
        count_table = Count(motifs)
        
        profile_table = pd.DataFrame(    np.full((4,self.k), self.pseudo)   , index=self.bases     )
        
        for x in range(self.k):
            total = sum(count_table[x])
            for base in self.bases:#           count / total
                profile_table.loc[base, x] = count_table.loc[base, x] / total
        return profile_table

    
    def Consensus(self, profile):
        # iterates over a profile and returns the consensus string according to
        # the max value and corresponding row (base) of each column
        consensus_string = ''
        for x in range(self.k):
            consensus_string += profile[x].idxmax()
            
        return consensus_string
    
    def motifs_from_profile(self, DNA, profile):
        # uses profile table to find the kmer with the best cumulative probability
        # in each sequence
        motifs = []
        for seq in DNA:
            best_prob = -1
            for x in range(len(seq)-self.k+1):
                kmer = seq[x:x+k]
                prob = 1
                for index, base in enumerate(kmer):
                    prob *= profile.loc[base, index]
                if prob > best_prob:
                    best_prob = prob
                    best_motif = kmer
            motifs.append(best_motif)
        return motifs
     
    def RandomizedMotifSearch(self):
        # conduct a depth-first search from randomly selected kmers
        best_motifs = self.rand_motifs()
        best_score = self.Score( self.Profile(best_motifs)  )

        while 1:
            profile = self.Profile(best_motifs)
            motifs = self.motifs_from_profile(self.DNA, profile)
            
            score = self.Score( self.Profile(motifs) )
            if score > best_score:
                best_motifs = motifs
                best_score = score

            else:
                return [best_motifs, best_score]
    
    def complete_search(self):
        # repeat randomized motif search a number of times and return the
        # consensus string with the best score
        final_list = []
        for x in range(self.iterations):
            motifs_candidate = self.RandomizedMotifSearch()
            final_list.append(motifs_candidate)
        final_motifs = sorted(final_list, key=lambda x: x[1], reverse=True)
        motifs, score = final_motifs[0]
        profile = self.Profile(motifs)
        return [self.Consensus(profile), score]
            
